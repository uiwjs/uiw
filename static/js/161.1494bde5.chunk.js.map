{"version":3,"sources":["../node_modules/codemirror/mode/sass/sass.js"],"names":["CodeMirror","defineMode","config","word","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","keywordsRegexp","RegExp","join","opRegexp","pseudoElementsRegexp","isEndLine","stream","peek","match","urlTokens","state","ch","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","skipToEnd","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","string","charAt","pos","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","currentOffset","scopes","offset","indentUnit","unshift","dedent","length","shift","eatWhile","current","toLowerCase","hasOwnProperty","prevProp","prop","startState","type","definedVars","definedMixins","token","style","withCurrentIndent","newScopes","i","scope","push","tokenLexer","lastToken","content","defineMIME","mod"],"mappings":"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","file":"static/js/161.1494bde5.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"sass\", function (config) {\n    var cssMode = CodeMirror.mimeModes[\"text/css\"];\n    var propertyKeywords = cssMode.propertyKeywords || {},\n        colorKeywords = cssMode.colorKeywords || {},\n        valueKeywords = cssMode.valueKeywords || {},\n        fontProperties = cssMode.fontProperties || {};\n\n    function tokenRegexp(words) {\n      return new RegExp(\"^\" + words.join(\"|\"));\n    }\n\n    var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n    var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n    var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\", \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\", \"\\\\{\", \"\\\\}\", \":\"];\n    var opRegexp = tokenRegexp(operators);\n    var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n    var word;\n\n    function isEndLine(stream) {\n      return !stream.peek() || stream.match(/\\s+$/, false);\n    }\n\n    function urlTokens(stream, state) {\n      var ch = stream.peek();\n\n      if (ch === \")\") {\n        stream.next();\n        state.tokenizer = tokenBase;\n        return \"operator\";\n      } else if (ch === \"(\") {\n        stream.next();\n        stream.eatSpace();\n        return \"operator\";\n      } else if (ch === \"'\" || ch === '\"') {\n        state.tokenizer = buildStringTokenizer(stream.next());\n        return \"string\";\n      } else {\n        state.tokenizer = buildStringTokenizer(\")\", false);\n        return \"string\";\n      }\n    }\n\n    function comment(indentation, multiLine) {\n      return function (stream, state) {\n        if (stream.sol() && stream.indentation() <= indentation) {\n          state.tokenizer = tokenBase;\n          return tokenBase(stream, state);\n        }\n\n        if (multiLine && stream.skipTo(\"*/\")) {\n          stream.next();\n          stream.next();\n          state.tokenizer = tokenBase;\n        } else {\n          stream.skipToEnd();\n        }\n\n        return \"comment\";\n      };\n    }\n\n    function buildStringTokenizer(quote, greedy) {\n      if (greedy == null) {\n        greedy = true;\n      }\n\n      function stringTokenizer(stream, state) {\n        var nextChar = stream.next();\n        var peekChar = stream.peek();\n        var previousChar = stream.string.charAt(stream.pos - 2);\n        var endingString = nextChar !== \"\\\\\" && peekChar === quote || nextChar === quote && previousChar !== \"\\\\\";\n\n        if (endingString) {\n          if (nextChar !== quote && greedy) {\n            stream.next();\n          }\n\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n\n          state.tokenizer = tokenBase;\n          return \"string\";\n        } else if (nextChar === \"#\" && peekChar === \"{\") {\n          state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n          stream.next();\n          return \"operator\";\n        } else {\n          return \"string\";\n        }\n      }\n\n      return stringTokenizer;\n    }\n\n    function buildInterpolationTokenizer(currentTokenizer) {\n      return function (stream, state) {\n        if (stream.peek() === \"}\") {\n          stream.next();\n          state.tokenizer = currentTokenizer;\n          return \"operator\";\n        } else {\n          return tokenBase(stream, state);\n        }\n      };\n    }\n\n    function indent(state) {\n      if (state.indentCount == 0) {\n        state.indentCount++;\n        var lastScopeOffset = state.scopes[0].offset;\n        var currentOffset = lastScopeOffset + config.indentUnit;\n        state.scopes.unshift({\n          offset: currentOffset\n        });\n      }\n    }\n\n    function dedent(state) {\n      if (state.scopes.length == 1) return;\n      state.scopes.shift();\n    }\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(); // Comment\n\n      if (stream.match(\"/*\")) {\n        state.tokenizer = comment(stream.indentation(), true);\n        return state.tokenizer(stream, state);\n      }\n\n      if (stream.match(\"//\")) {\n        state.tokenizer = comment(stream.indentation(), false);\n        return state.tokenizer(stream, state);\n      } // Interpolation\n\n\n      if (stream.match(\"#{\")) {\n        state.tokenizer = buildInterpolationTokenizer(tokenBase);\n        return \"operator\";\n      } // Strings\n\n\n      if (ch === '\"' || ch === \"'\") {\n        stream.next();\n        state.tokenizer = buildStringTokenizer(ch);\n        return \"string\";\n      }\n\n      if (!state.cursorHalf) {\n        // state.cursorHalf === 0\n        // first half i.e. before : for key-value pairs\n        // including selectors\n        if (ch === \"-\") {\n          if (stream.match(/^-\\w+-/)) {\n            return \"meta\";\n          }\n        }\n\n        if (ch === \".\") {\n          stream.next();\n\n          if (stream.match(/^[\\w-]+/)) {\n            indent(state);\n            return \"qualifier\";\n          } else if (stream.peek() === \"#\") {\n            indent(state);\n            return \"tag\";\n          }\n        }\n\n        if (ch === \"#\") {\n          stream.next(); // ID selectors\n\n          if (stream.match(/^[\\w-]+/)) {\n            indent(state);\n            return \"builtin\";\n          }\n\n          if (stream.peek() === \"#\") {\n            indent(state);\n            return \"tag\";\n          }\n        } // Variables\n\n\n        if (ch === \"$\") {\n          stream.next();\n          stream.eatWhile(/[\\w-]/);\n          return \"variable-2\";\n        } // Numbers\n\n\n        if (stream.match(/^-?[0-9\\.]+/)) return \"number\"; // Units\n\n        if (stream.match(/^(px|em|in)\\b/)) return \"unit\";\n        if (stream.match(keywordsRegexp)) return \"keyword\";\n\n        if (stream.match(/^url/) && stream.peek() === \"(\") {\n          state.tokenizer = urlTokens;\n          return \"atom\";\n        }\n\n        if (ch === \"=\") {\n          // Match shortcut mixin definition\n          if (stream.match(/^=[\\w-]+/)) {\n            indent(state);\n            return \"meta\";\n          }\n        }\n\n        if (ch === \"+\") {\n          // Match shortcut mixin definition\n          if (stream.match(/^\\+[\\w-]+/)) {\n            return \"variable-3\";\n          }\n        }\n\n        if (ch === \"@\") {\n          if (stream.match(/@extend/)) {\n            if (!stream.match(/\\s*[\\w]/)) dedent(state);\n          }\n        } // Indent Directives\n\n\n        if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n          indent(state);\n          return \"def\";\n        } // Other Directives\n\n\n        if (ch === \"@\") {\n          stream.next();\n          stream.eatWhile(/[\\w-]/);\n          return \"def\";\n        }\n\n        if (stream.eatWhile(/[\\w-]/)) {\n          if (stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/, false)) {\n            word = stream.current().toLowerCase();\n            var prop = state.prevProp + \"-\" + word;\n\n            if (propertyKeywords.hasOwnProperty(prop)) {\n              return \"property\";\n            } else if (propertyKeywords.hasOwnProperty(word)) {\n              state.prevProp = word;\n              return \"property\";\n            } else if (fontProperties.hasOwnProperty(word)) {\n              return \"property\";\n            }\n\n            return \"tag\";\n          } else if (stream.match(/ *:/, false)) {\n            indent(state);\n            state.cursorHalf = 1;\n            state.prevProp = stream.current().toLowerCase();\n            return \"property\";\n          } else if (stream.match(/ *,/, false)) {\n            return \"tag\";\n          } else {\n            indent(state);\n            return \"tag\";\n          }\n        }\n\n        if (ch === \":\") {\n          if (stream.match(pseudoElementsRegexp)) {\n            // could be a pseudo-element\n            return \"variable-3\";\n          }\n\n          stream.next();\n          state.cursorHalf = 1;\n          return \"operator\";\n        }\n      } // cursorHalf===0 ends here\n      else {\n          if (ch === \"#\") {\n            stream.next(); // Hex numbers\n\n            if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n              if (isEndLine(stream)) {\n                state.cursorHalf = 0;\n              }\n\n              return \"number\";\n            }\n          } // Numbers\n\n\n          if (stream.match(/^-?[0-9\\.]+/)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"number\";\n          } // Units\n\n\n          if (stream.match(/^(px|em|in)\\b/)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"unit\";\n          }\n\n          if (stream.match(keywordsRegexp)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"keyword\";\n          }\n\n          if (stream.match(/^url/) && stream.peek() === \"(\") {\n            state.tokenizer = urlTokens;\n\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"atom\";\n          } // Variables\n\n\n          if (ch === \"$\") {\n            stream.next();\n            stream.eatWhile(/[\\w-]/);\n\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"variable-2\";\n          } // bang character for !important, !default, etc.\n\n\n          if (ch === \"!\") {\n            stream.next();\n            state.cursorHalf = 0;\n            return stream.match(/^[\\w]+/) ? \"keyword\" : \"operator\";\n          }\n\n          if (stream.match(opRegexp)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            return \"operator\";\n          } // attributes\n\n\n          if (stream.eatWhile(/[\\w-]/)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n\n            word = stream.current().toLowerCase();\n\n            if (valueKeywords.hasOwnProperty(word)) {\n              return \"atom\";\n            } else if (colorKeywords.hasOwnProperty(word)) {\n              return \"keyword\";\n            } else if (propertyKeywords.hasOwnProperty(word)) {\n              state.prevProp = stream.current().toLowerCase();\n              return \"property\";\n            } else {\n              return \"tag\";\n            }\n          } //stream.eatSpace();\n\n\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n            return null;\n          }\n        } // else ends here\n\n\n      if (stream.match(opRegexp)) return \"operator\"; // If we haven't returned by now, we move 1 character\n      // and return an error\n\n      stream.next();\n      return null;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.indentCount = 0;\n      var style = state.tokenizer(stream, state);\n      var current = stream.current();\n\n      if (current === \"@return\" || current === \"}\") {\n        dedent(state);\n      }\n\n      if (style !== null) {\n        var startOfToken = stream.pos - current.length;\n        var withCurrentIndent = startOfToken + config.indentUnit * state.indentCount;\n        var newScopes = [];\n\n        for (var i = 0; i < state.scopes.length; i++) {\n          var scope = state.scopes[i];\n          if (scope.offset <= withCurrentIndent) newScopes.push(scope);\n        }\n\n        state.scopes = newScopes;\n      }\n\n      return style;\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenizer: tokenBase,\n          scopes: [{\n            offset: 0,\n            type: \"sass\"\n          }],\n          indentCount: 0,\n          cursorHalf: 0,\n          // cursor half tells us if cursor lies after (1)\n          // or before (0) colon (well... more or less)\n          definedVars: [],\n          definedMixins: []\n        };\n      },\n      token: function (stream, state) {\n        var style = tokenLexer(stream, state);\n        state.lastToken = {\n          style: style,\n          content: stream.current()\n        };\n        return style;\n      },\n      indent: function (state) {\n        return state.scopes[0].offset;\n      }\n    };\n  }, \"css\");\n  CodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n});"],"sourceRoot":""}