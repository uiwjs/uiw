(window.webpackJsonp=window.webpackJsonp||[]).push([[388],{728:function(n,t){n.exports="Drawer 抽屉\n===\n\n一个从页面边缘滑动出来的浮层，可以替代 [`<Modal>`](#/components/modal) 更多样的展示方式。\n\n```jsx\nimport { Drawer } from 'uiw';\n```\n\n### 基础用法\n\n\x3c!--DemoStart,bgWhite,codePen--\x3e \n```js\nimport { Drawer, ButtonGroup, Button } from 'uiw';\n\nclass Demo extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      visible: false,\n    }\n  }\n  onClick() {\n    this.setState({ visible: !this.state.visible });\n  }\n  onClose() {\n    this.setState({ visible: false });\n  }\n  render() {\n    return (\n      <div>\n        <Drawer\n          title=\"抽屉标题\"\n          isOpen={this.state.visible}\n          onClose={this.onClose.bind(this)}\n        >\n          React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。\n          <br /><br />\n          以声明式编写UI，可以让你的代码更加可靠，且方便调试。\n          <br /><br />\n          创建好拥有各自状态的组件，再由组件构成更加复杂的界面。\n          <br /><br />\n          无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。\n          <br /><br />\n          无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。\n          <br /><br />\n          <b>组件</b>\n          <br /><br />\n          React 组件使用一个名为 render() 的方法， 接收数据作为输入，输出页面中对应展示的内容。 下面这个示例中类似XML的写法被称为JSX. 输入的数据通过 this.props 传入 render() 方法。\n        </Drawer>\n        <ButtonGroup>\n          <Button onClick={this.onClick.bind(this)}>打开抽屉</Button>\n        </ButtonGroup>\n      </div>\n    )\n  }\n}\nReactDOM.render(<Demo />, _mount_);\n```\n\x3c!--End--\x3e\n\n### 显示位置\n\n\x3c!--DemoStart,bgWhite,codePen--\x3e \n```js\nimport { Drawer, ButtonGroup, Button } from 'uiw';\n\nclass Demo extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      visible: false,\n      placement: null,\n    }\n  }\n  onClick(placement) {\n    this.setState({ visible: !this.state.visible, placement });\n  }\n  onClose() {\n    this.setState({ visible: false });\n  }\n  render() {\n    return (\n      <div>\n        <Drawer\n          title=\"抽屉标题\"\n          icon=\"information\"\n          placement={this.state.placement}\n          isOpen={this.state.visible}\n          footer=\"页脚，可以放点内容\"\n          onClose={this.onClose.bind(this)}\n        >\n          React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。\n          <br /><br />\n          以声明式编写UI，可以让你的代码更加可靠，且方便调试。\n          <br /><br />\n          创建好拥有各自状态的组件，再由组件构成更加复杂的界面。\n          <br /><br />\n          无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。\n          <br /><br />\n          无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。\n          <br /><br />\n          <b>组件</b>'top', 'right', 'bottom', 'left'\n        </Drawer>\n        <ButtonGroup>\n          <Button onClick={this.onClick.bind(this, 'left')}>Left</Button>\n          <Button onClick={this.onClick.bind(this, 'top')}>Top</Button>\n          <Button onClick={this.onClick.bind(this, 'bottom')}>Bottom</Button>\n          <Button onClick={this.onClick.bind(this, 'right')}>Right</Button>\n        </ButtonGroup>\n      </div>\n    )\n  }\n}\nReactDOM.render(<Demo />, _mount_);\n```\n\x3c!--End--\x3e\n\n\n### 添加页脚\n\n\x3c!--DemoStart,bgWhite,codePen--\x3e \n```js\nimport { Drawer, ButtonGroup, Button } from 'uiw';\n\nclass Demo extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      visible: false,\n    }\n  }\n  onClick() {\n    this.setState({ visible: !this.state.visible });\n  }\n  onClose() {\n    this.setState({ visible: false });\n  }\n  render() {\n    return (\n      <div>\n        <Drawer\n          title=\"抽屉标题\"\n          isOpen={this.state.visible}\n          onClose={this.onClose.bind(this)}\n          footer={\n            <div>\n              <Button size=\"small\" type=\"danger\" onClick={this.onClick.bind(this)}>关闭抽屉</Button>\n              <Button size=\"small\" type=\"success\">其它</Button>\n            </div>\n          }\n        >\n          React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。\n          <br /><br />\n          以声明式编写UI，可以让你的代码更加可靠，且方便调试。\n          <br /><br />\n          创建好拥有各自状态的组件，再由组件构成更加复杂的界面。\n          <br /><br />\n          无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。\n          <br /><br />\n          无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。\n          <br /><br />\n          <b>组件</b>\n          <br /><br />\n          React 组件使用一个名为 render() 的方法， 接收数据作为输入，输出页面中对应展示的内容。 下面这个示例中类似XML的写法被称为JSX. 输入的数据通过 this.props 传入 render() 方法。\n        </Drawer>\n        <ButtonGroup>\n          <Button onClick={this.onClick.bind(this)}>打开抽屉</Button>\n        </ButtonGroup>\n      </div>\n    )\n  }\n}\nReactDOM.render(<Demo />, _mount_);\n```\n\x3c!--End--\x3e\n\n## Props\n\n| 参数 | 说明 | 类型 | 默认值 |\n|--------- |-------- |--------- |-------- |\n| title | 抽屉标题 | String | - |\n| icon | 设置对话框右上角图标 | String/Element | - |\n| isOpen | 是否可见 | Boollean | - |\n| closable | 是否显示右上角的关闭按钮 | Boollean | `true` |\n| placement | 抽屉的方向 | Enum{`top`, `right`, `bottom`, `left`} | `right` |\n| size | 高度/宽度，在 `placement` 为 `top` 或 `bottom` 时使用为设置高度，否则设置宽度 | Number | - |\n\n更多属性文档请参考 [Overlay](#/components/overlay)。"}}]);