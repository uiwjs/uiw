{"version":3,"sources":["../node_modules/codemirror/mode/xquery/xquery.js"],"names":["CodeMirror","defineMode","keywords","kw","type","style","operator","atom","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","current","match","isEQNameAhead","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","c","tagName","name","popStateStack","pushStateStack","tokenAttribute","tokenTag","isInXmlBlock","test","tokenComment","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","isIn","isInXmlConstructor","tokenString","maybeEnd","maybeNested","nestedCount","quote","isInString","isInXmlAttributeBlock","isVariableChar","stack","newState","push","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME","mod"],"mappings":"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","file":"static/js/189.391afd7e.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"xquery\", function () {\n    // The keywords object is set to the result of this self executing\n    // function. Each keyword is a property of the keywords object whose\n    // value is {type: atype, style: astyle}\n    var keywords = function () {\n      // convenience functions used to build keywords object\n      function kw(type) {\n        return {\n          type: type,\n          style: \"keyword\"\n        };\n      }\n\n      var operator = kw(\"operator\"),\n          atom = {\n        type: \"atom\",\n        style: \"atom\"\n      },\n          punctuation = {\n        type: \"punctuation\",\n        style: null\n      },\n          qualifier = {\n        type: \"axis_specifier\",\n        style: \"qualifier\"\n      }; // kwObj is what is return from this function at the end\n\n      var kwObj = {\n        ',': punctuation\n      }; // a list of 'basic' keywords. For each add a property to kwObj with the value of\n      // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n\n      var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n\n      for (var i = 0, l = basic.length; i < l; i++) {\n        kwObj[basic[i]] = kw(basic[i]);\n      }\n\n      ; // a list of types. For each add a property to kwObj with the value of\n      // {type: \"atom\", style: \"atom\"}\n\n      var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n\n      for (var i = 0, l = types.length; i < l; i++) {\n        kwObj[types[i]] = atom;\n      }\n\n      ; // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n\n      var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n\n      for (var i = 0, l = operators.length; i < l; i++) {\n        kwObj[operators[i]] = operator;\n      }\n\n      ; // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n\n      var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n\n      for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n        kwObj[axis_specifiers[i]] = qualifier;\n      }\n\n      ;\n      return kwObj;\n    }();\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    } // the primary mode tokenizer\n\n\n    function tokenBase(stream, state) {\n      var ch = stream.next(),\n          mightBeFunction = false,\n          isEQName = isEQNameAhead(stream); // an XML tag (if not in some sub, chained tokenizer)\n\n      if (ch == \"<\") {\n        if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n\n        if (stream.match(\"![CDATA\", false)) {\n          state.tokenize = tokenCDATA;\n          return \"tag\";\n        }\n\n        if (stream.match(\"?\", false)) {\n          return chain(stream, state, tokenPreProcessing);\n        }\n\n        var isclose = stream.eat(\"/\");\n        stream.eatSpace();\n        var tagName = \"\",\n            c;\n\n        while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) tagName += c;\n\n        return chain(stream, state, tokenTag(tagName, isclose));\n      } // start code block\n      else if (ch == \"{\") {\n          pushStateStack(state, {\n            type: \"codeblock\"\n          });\n          return null;\n        } // end code block\n        else if (ch == \"}\") {\n            popStateStack(state);\n            return null;\n          } // if we're in an XML block\n          else if (isInXmlBlock(state)) {\n              if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n                popStateStack(state);\n                return \"tag\";\n              } else return \"variable\";\n            } // if a number\n            else if (/\\d/.test(ch)) {\n                stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n                return \"atom\";\n              } // comment start\n              else if (ch === \"(\" && stream.eat(\":\")) {\n                  pushStateStack(state, {\n                    type: \"comment\"\n                  });\n                  return chain(stream, state, tokenComment);\n                } // quoted string\n                else if (!isEQName && (ch === '\"' || ch === \"'\")) return chain(stream, state, tokenString(ch)); // variable\n                  else if (ch === \"$\") {\n                      return chain(stream, state, tokenVariable);\n                    } // assignment\n                    else if (ch === \":\" && stream.eat(\"=\")) {\n                        return \"keyword\";\n                      } // open paren\n                      else if (ch === \"(\") {\n                          pushStateStack(state, {\n                            type: \"paren\"\n                          });\n                          return null;\n                        } // close paren\n                        else if (ch === \")\") {\n                            popStateStack(state);\n                            return null;\n                          } // open paren\n                          else if (ch === \"[\") {\n                              pushStateStack(state, {\n                                type: \"bracket\"\n                              });\n                              return null;\n                            } // close paren\n                            else if (ch === \"]\") {\n                                popStateStack(state);\n                                return null;\n                              } else {\n                                var known = keywords.propertyIsEnumerable(ch) && keywords[ch]; // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n\n                                if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n                                if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {} // gobble up a word if the character is not known\n\n                                if (!known) stream.eatWhile(/[\\w\\$_-]/); // gobble a colon in the case that is a lib func type call fn:doc\n\n                                var foundColon = stream.eat(\":\"); // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n                                // which should get matched as a keyword\n\n                                if (!stream.eat(\":\") && foundColon) {\n                                  stream.eatWhile(/[\\w\\$_-]/);\n                                } // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n\n\n                                if (stream.match(/^[ \\t]*\\(/, false)) {\n                                  mightBeFunction = true;\n                                } // is the word a keyword?\n\n\n                                var word = stream.current();\n                                known = keywords.propertyIsEnumerable(word) && keywords[word]; // if we think it's a function call but not yet known,\n                                // set style to variable for now for lack of something better\n\n                                if (mightBeFunction && !known) known = {\n                                  type: \"function_call\",\n                                  style: \"variable def\"\n                                }; // if the previous word was element, attribute, axis specifier, this word should be the name of that\n\n                                if (isInXmlConstructor(state)) {\n                                  popStateStack(state);\n                                  return \"variable\";\n                                } // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n                                // push the stack so we know to look for it on the next word\n\n\n                                if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n                                  type: \"xmlconstructor\"\n                                }); // if the word is known, return the details of that else just call this a generic 'word'\n\n                                return known ? known.style : \"variable\";\n                              }\n    } // handle comments, including nested\n\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          maybeNested = false,\n          nestedCount = 0,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          if (nestedCount > 0) nestedCount--;else {\n            popStateStack(state);\n            break;\n          }\n        } else if (ch == \":\" && maybeNested) {\n          nestedCount++;\n        }\n\n        maybeEnd = ch == \":\";\n        maybeNested = ch == \"(\";\n      }\n\n      return \"comment\";\n    } // tokenizer for string literals\n    // optionally pass a tokenizer function to set state.tokenize back to when finished\n\n\n    function tokenString(quote, f) {\n      return function (stream, state) {\n        var ch;\n\n        if (isInString(state) && stream.current() == quote) {\n          popStateStack(state);\n          if (f) state.tokenize = f;\n          return \"string\";\n        }\n\n        pushStateStack(state, {\n          type: \"string\",\n          name: quote,\n          tokenize: tokenString(quote, f)\n        }); // if we're in a string and in an XML block, allow an embedded code block\n\n        if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n        while (ch = stream.next()) {\n          if (ch == quote) {\n            popStateStack(state);\n            if (f) state.tokenize = f;\n            break;\n          } else {\n            // if we're in a string and in an XML block, allow an embedded code block in an attribute\n            if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n              state.tokenize = tokenBase;\n              return \"string\";\n            }\n          }\n        }\n\n        return \"string\";\n      };\n    } // tokenizer for variables\n\n\n    function tokenVariable(stream, state) {\n      var isVariableChar = /[\\w\\$_-]/; // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n\n      if (stream.eat(\"\\\"\")) {\n        while (stream.next() !== '\\\"') {}\n\n        ;\n        stream.eat(\":\");\n      } else {\n        stream.eatWhile(isVariableChar);\n        if (!stream.match(\":=\", false)) stream.eat(\":\");\n      }\n\n      stream.eatWhile(isVariableChar);\n      state.tokenize = tokenBase;\n      return \"variable\";\n    } // tokenizer for XML tags\n\n\n    function tokenTag(name, isclose) {\n      return function (stream, state) {\n        stream.eatSpace();\n\n        if (isclose && stream.eat(\">\")) {\n          popStateStack(state);\n          state.tokenize = tokenBase;\n          return \"tag\";\n        } // self closing tag without attributes?\n\n\n        if (!stream.eat(\"/\")) pushStateStack(state, {\n          type: \"tag\",\n          name: name,\n          tokenize: tokenBase\n        });\n\n        if (!stream.eat(\">\")) {\n          state.tokenize = tokenAttribute;\n          return \"tag\";\n        } else {\n          state.tokenize = tokenBase;\n        }\n\n        return \"tag\";\n      };\n    } // tokenizer for XML attributes\n\n\n    function tokenAttribute(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"/\" && stream.eat(\">\")) {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        if (isInXmlBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \">\") {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \"=\") return null; // quoted string\n\n      if (ch == '\"' || ch == \"'\") return chain(stream, state, tokenString(ch, tokenAttribute));\n      if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n        type: \"attribute\",\n        tokenize: tokenAttribute\n      });\n      stream.eat(/[a-zA-Z_:]/);\n      stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n      stream.eatSpace(); // the case where the attribute has not value and the tag was closed\n\n      if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n      }\n\n      return \"attribute\";\n    } // handle comments, including nested\n\n\n    function tokenXMLComment(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"-\" && stream.match(\"->\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle CDATA\n\n\n    function tokenCDATA(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"]\" && stream.match(\"]\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle preprocessing instructions\n\n\n    function tokenPreProcessing(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"?\" && stream.match(\">\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment meta\";\n        }\n      }\n    } // functions to test the current context of the state\n\n\n    function isInXmlBlock(state) {\n      return isIn(state, \"tag\");\n    }\n\n    function isInXmlAttributeBlock(state) {\n      return isIn(state, \"attribute\");\n    }\n\n    function isInXmlConstructor(state) {\n      return isIn(state, \"xmlconstructor\");\n    }\n\n    function isInString(state) {\n      return isIn(state, \"string\");\n    }\n\n    function isEQNameAhead(stream) {\n      // assume we've already eaten a quote (\")\n      if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n    }\n\n    function isIn(state, type) {\n      return state.stack.length && state.stack[state.stack.length - 1].type == type;\n    }\n\n    function pushStateStack(state, newState) {\n      state.stack.push(newState);\n    }\n\n    function popStateStack(state) {\n      state.stack.pop();\n      var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n      state.tokenize = reinstateTokenize || tokenBase;\n    } // the interface for the mode API\n\n\n    return {\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          cc: [],\n          stack: []\n        };\n      },\n      token: function (stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        return style;\n      },\n      blockCommentStart: \"(:\",\n      blockCommentEnd: \":)\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n});"],"sourceRoot":""}