{"version":3,"sources":["../../../node_modules/@babel/traverse/lib/context.js","../../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../../node_modules/@babel/traverse/lib/path/ancestry.js","../../../node_modules/@babel/traverse/lib/path/inference/index.js","../../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../../node_modules/@babel/traverse/lib/path/replacement.js","../../../node_modules/@babel/traverse/lib/path/evaluation.js","../../../node_modules/@babel/traverse/lib/path/conversion.js","../../../node_modules/@babel/traverse/lib/path/introspection.js","../../../node_modules/@babel/traverse/lib/path/context.js","../../../node_modules/@babel/traverse/lib/path/removal.js","../../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../../node_modules/@babel/traverse/lib/path/modification.js","../../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../../node_modules/@babel/traverse/lib/path/family.js","../../../node_modules/@babel/traverse/lib/path/comments.js","../../../node_modules/@babel/traverse/lib/visitors.js","../../../node_modules/@babel/traverse/lib/hub.js","../../../node_modules/@babel/traverse/lib/index.js","../../../node_modules/@babel/traverse/lib/path/index.js","../../../node_modules/@babel/traverse/lib/cache.js","../../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../../node_modules/@babel/traverse/lib/scope/index.js","../../../node_modules/@babel/traverse/lib/scope/binding.js"],"names":["Object","defineProperty","exports","value","default","obj","_path","require","__esModule","t","cache","_getRequireWildcardCache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","WeakMap","TraversalContext","scope","opts","state","parentPath","this","queue","node","enter","exit","type","keys","VISITOR_KEYS","length","listKey","parent","container","path","notPriority","trap","Error","push","priorityQueue","shouldVisit","create","visitQueue","visited","WeakSet","stop","resync","contexts","pushContext","process","add","visit","popContext","nodes","Array","isArray","visitMultiple","visitSingle","_interopRequireDefault","_helperSplitExportDeclaration","renameVisitor","ReferencedIdentifier","name","oldName","newName","Scope","bindingIdentifierEquals","binding","identifier","skip","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","parentDeclar","maybeExportDeclar","isExportDeclaration","isExportDefaultDeclaration","id","block","find","isDeclaration","isFunctionExpression","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","traverse","removeOwnBinding","bindings","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","getFunctionParent","p","isFunction","getStatementParent","isStatement","isProgram","isFile","getEarliestCommonAncestorFrom","paths","getDeepestCommonAncestorFrom","deepest","i","ancestries","earliest","indexOf","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","map","ancestry","unshift","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","arguments","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declar","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","delete","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","types","type2","baseTypeStrictlyMatches","right","left","isFlowBaseAnnotation","isGenericType","genericName","isGenericTypeAnnotation","isIdentifier","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","init","isCallExpression","hasBinding","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","callee","TemplateLiteral","UnaryExpression","operator","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","enumerable","_infererReference","buildMatchMemberExpression","resolve","is","returnType","isReferenced","getBinding","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","violations","slice","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","_cache","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","loc","message","_codeFrame","codeFrameColumns","start","line","column","code","program","body","expression","_index","removeProperties","replaceWith","removed","_index2","nodePath","isNodeType","isExpression","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","ReferenceError","inList","validate","debug","toSequenceExpression","functionParent","isParentAsync","arrowFunctionExpression","blockStatement","callExpression","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","returnStatement","cloneNode","setData","assignmentExpression","arrowFunctionToExpression","hasType","FUNCTION_TYPES","awaitExpression","replaceInline","_containerInsertAfter","Function","VariableDeclaration","kind","getBindingIdentifiers","exprs","declarations","evaluateTruthy","res","evaluate","confident","deoptPath","seen","Map","evaluateCached","undefined","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","val","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","property","quasi","testResult","isExpressionWrapper","isReferencedIdentifier","end","hasValue","NaN","prefix","argument","isClass","arg","isArrayExpression","arr","elems","elemValue","isObjectExpression","props","prop","isObjectMethod","isSpreadElement","computed","wasConfident","leftConfident","rightConfident","Math","pow","context","func","global","args","apply","_evaluate","raw","str","elem","cooked","expr","String","toComputedKey","isProperty","isMethod","stringLiteral","ensureBlock","bodyNode","isBlockStatement","statements","stringPath","setup","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","thisBinding","checkBinding","generateUidIdentifier","objectExpression","unshiftContainer","hub","addHelper","thisExpression","memberExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","isSuper","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","parts","numericLiteral","sequenceExpression","isClassMethod","superClass","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","method","valueIdent","cacheKey","data","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","MetaProperty","matchesPattern","pattern","allowPartial","isStatic","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","includes","referencesImport","moduleSource","importName","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","references","allStatus","referencePaths","executionOrderCheckedNodes","dangerous","_resolve","constant","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","getProgramParent","isExecutionUncertain","maxIndex","_call","fns","fn","then","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","shouldSkip","shouldStop","skipKeys","skipKey","SHOULD_SKIP","SHOULD_STOP","noScope","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","REMOVED","self","isWhile","isSwitchCase","expressions","isBinary","insertBefore","isExportNamedDeclaration","isJSXElement","isForStatement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","temp","fromIndex","incrementBy","constructor","msg","hoist","hoister","_hoister","run","referenceVisitor","isJSXIdentifier","react","isCompatTag","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","hasOwnBinding","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","getCompatibleScopes","attachTo","getAttachmentPath","declarator","variableDeclarator","variableDeclaration","attached","children","JSXExpressionContainer","getOpposite","addCompletionRecords","isDoExpression","isTryStatement","isCatchClause","isSwitchStatement","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","declaration","getOuterBindingIdentifierPaths","_findBreak","_findBreak2","isBreakStatement","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","assign","_verified","validateVisitorMethods","TYPES","visitorKey","TypeError","oldVisitor","newVisitor","newFn","toString","checkPath","dest","src","Hub","_scope","_hub","_context","hasDenylistedType","cheap","traverseFast","clearNode","tree","denylistTypes","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","isScope","def","SyntaxError","buildError","join","enabled","getPathLocation","v","targetNode","typeKey","virtualType","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","grandparent","isBinding","isForXStatement","isBlockScoped","isVar","isUser","isPure","isFlow","importKind","exportKind","isObjectPattern","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","specifiers","isModuleSpecifier","local","properties","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","registerBinding","Declaration","registerDeclaration","ForXStatement","isPattern","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","addGlobal","getBlockParent","assignments","Block","bodyPath","CatchClause","NOT_LOCAL_BINDING","params","param","cached","labels","inited","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasGlobal","hasReference","uids","defaultName","generateUidBasedOnNode","isThisExpression","dontPush","generateUidIdentifierBasedOnNode","rename","sep","repeat","log","allowArrayLike","helperName","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","globals","constantsOnly","isClassBody","elements","tag","isPureish","crawl","programParent","crawling","ref","unique","blockHoist","dataKey","declarPath","isFunctionParent","isBlockParent","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","contextVariables","_this$parent","info","_this$getBinding2","builtin","Binding","referenced","clearValue","hasDeoptedValue"],"mappings":"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","file":"static/js/vendors-runtime-traverse.2f51eabe.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType() {\n  let path = this;\n\n  while (path) {\n    for (const type of arguments) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  const left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  const {\n    node\n  } = path;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  const node = this.node;\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.get(\"operator\").node !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    let {\n      node\n    } = path;\n    if (path.isFunction()) node = node.body;\n\n    for (const directive of node.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      let {\n        scope\n      } = this;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nexports.default = NodePath;\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if (node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if (node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent == null ? void 0 : parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, allowArrayLike) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (allowArrayLike) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isFunction()) {\n      if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;"],"sourceRoot":""}