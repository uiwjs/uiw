{"version":3,"sources":["../node_modules/codemirror/mode/vb/vb.js"],"names":["CodeMirror","defineMode","conf","parserConf","ERRORCLASS","wordRegexp","words","RegExp","join","singleOperators","singleDelimiters","doubleOperators","doubleDelimiters","tripleDelimiters","identifiers","openingKeywords","middleKeywords","endKeywords","operatorKeywords","wordOperators","commonKeywords","commontypes","keywords","types","stringPrefixes","opening","middle","closing","doubleClosing","doOpening","indentInfo","indent","_stream","state","currentIndent","dedent","tokenBase","stream","eatSpace","peek","skipToEnd","match","floatLiteral","eat","intLiteral","tokenize","delimiter","singleline","length","eol","eatWhile","singleLineStringErrors","tokenStringFactory","current","doInCurrentLine","next","registerHelper","concat","electricChars","startState","lastToken","nextLineIndent","token","sol","style","delimiter_index","indexOf","tokenLexer","content","textAfter","trueText","replace","indentUnit","lineComment","defineMIME","mod"],"mappings":"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","file":"static/js/182.d8461e7e.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"vb\", function (conf, parserConf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&\\\\\\\\|\\\\^~<>!]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}@,:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\\\*\\\\*))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z][_A-Za-z0-9]*\");\n    var openingKeywords = ['class', 'module', 'sub', 'enum', 'select', 'while', 'if', 'function', 'get', 'set', 'property', 'try', 'structure', 'synclock', 'using', 'with'];\n    var middleKeywords = ['else', 'elseif', 'case', 'catch', 'finally'];\n    var endKeywords = ['next', 'loop'];\n    var operatorKeywords = ['and', \"andalso\", 'or', 'orelse', 'xor', 'in', 'not', 'is', 'isnot', 'like'];\n    var wordOperators = wordRegexp(operatorKeywords);\n    var commonKeywords = [\"#const\", \"#else\", \"#elseif\", \"#end\", \"#if\", \"#region\", \"addhandler\", \"addressof\", \"alias\", \"as\", \"byref\", \"byval\", \"cbool\", \"cbyte\", \"cchar\", \"cdate\", \"cdbl\", \"cdec\", \"cint\", \"clng\", \"cobj\", \"compare\", \"const\", \"continue\", \"csbyte\", \"cshort\", \"csng\", \"cstr\", \"cuint\", \"culng\", \"cushort\", \"declare\", \"default\", \"delegate\", \"dim\", \"directcast\", \"each\", \"erase\", \"error\", \"event\", \"exit\", \"explicit\", \"false\", \"for\", \"friend\", \"gettype\", \"goto\", \"handles\", \"implements\", \"imports\", \"infer\", \"inherits\", \"interface\", \"isfalse\", \"istrue\", \"lib\", \"me\", \"mod\", \"mustinherit\", \"mustoverride\", \"my\", \"mybase\", \"myclass\", \"namespace\", \"narrowing\", \"new\", \"nothing\", \"notinheritable\", \"notoverridable\", \"of\", \"off\", \"on\", \"operator\", \"option\", \"optional\", \"out\", \"overloads\", \"overridable\", \"overrides\", \"paramarray\", \"partial\", \"private\", \"protected\", \"public\", \"raiseevent\", \"readonly\", \"redim\", \"removehandler\", \"resume\", \"return\", \"shadows\", \"shared\", \"static\", \"step\", \"stop\", \"strict\", \"then\", \"throw\", \"to\", \"true\", \"trycast\", \"typeof\", \"until\", \"until\", \"when\", \"widening\", \"withevents\", \"writeonly\"];\n    var commontypes = ['object', 'boolean', 'char', 'string', 'byte', 'sbyte', 'short', 'ushort', 'int16', 'uint16', 'integer', 'uinteger', 'int32', 'uint32', 'long', 'ulong', 'int64', 'uint64', 'decimal', 'single', 'double', 'float', 'date', 'datetime', 'intptr', 'uintptr'];\n    var keywords = wordRegexp(commonKeywords);\n    var types = wordRegexp(commontypes);\n    var stringPrefixes = '\"';\n    var opening = wordRegexp(openingKeywords);\n    var middle = wordRegexp(middleKeywords);\n    var closing = wordRegexp(endKeywords);\n    var doubleClosing = wordRegexp(['end']);\n    var doOpening = wordRegexp(['do']);\n    var indentInfo = null;\n    CodeMirror.registerHelper(\"hintWords\", \"vb\", openingKeywords.concat(middleKeywords).concat(endKeywords).concat(operatorKeywords).concat(commonKeywords).concat(commontypes));\n\n    function indent(_stream, state) {\n      state.currentIndent++;\n    }\n\n    function dedent(_stream, state) {\n      state.currentIndent--;\n    } // tokenizers\n\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var ch = stream.peek(); // Handle Comments\n\n      if (ch === \"'\") {\n        stream.skipToEnd();\n        return 'comment';\n      } // Handle Number Literals\n\n\n      if (stream.match(/^((&H)|(&O))?[0-9\\.a-f]/i, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^\\d*\\.\\d+F?/i)) {\n          floatLiteral = true;\n        } else if (stream.match(/^\\d+\\.\\d*F?/)) {\n          floatLiteral = true;\n        } else if (stream.match(/^\\.\\d+F?/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return 'number';\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^&H[0-9a-f]+/i)) {\n          intLiteral = true;\n        } // Octal\n        else if (stream.match(/^&O[0-7]+/i)) {\n            intLiteral = true;\n          } // Decimal\n          else if (stream.match(/^[1-9]\\d*F?/)) {\n              // Decimal literals may be \"imaginary\"\n              stream.eat(/J/i); // TODO - Can you have imaginary longs?\n\n              intLiteral = true;\n            } // Zero by itself with no other piece of number.\n            else if (stream.match(/^0(?![\\dx])/i)) {\n                intLiteral = true;\n              }\n\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return 'number';\n        }\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenStringFactory(stream.current());\n        return state.tokenize(stream, state);\n      } // Handle operators and Delimiters\n\n\n      if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n        return null;\n      }\n\n      if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {\n        return 'operator';\n      }\n\n      if (stream.match(singleDelimiters)) {\n        return null;\n      }\n\n      if (stream.match(doOpening)) {\n        indent(stream, state);\n        state.doInCurrentLine = true;\n        return 'keyword';\n      }\n\n      if (stream.match(opening)) {\n        if (!state.doInCurrentLine) indent(stream, state);else state.doInCurrentLine = false;\n        return 'keyword';\n      }\n\n      if (stream.match(middle)) {\n        return 'keyword';\n      }\n\n      if (stream.match(doubleClosing)) {\n        dedent(stream, state);\n        dedent(stream, state);\n        return 'keyword';\n      }\n\n      if (stream.match(closing)) {\n        dedent(stream, state);\n        return 'keyword';\n      }\n\n      if (stream.match(types)) {\n        return 'keyword';\n      }\n\n      if (stream.match(keywords)) {\n        return 'keyword';\n      }\n\n      if (stream.match(identifiers)) {\n        return 'variable';\n      } // Handle non-detected items\n\n\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = 'string';\n      return function (stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"]/);\n\n          if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) {\n            return ERRORCLASS;\n          } else {\n            state.tokenize = tokenBase;\n          }\n        }\n\n        return OUTCLASS;\n      };\n    }\n\n    function tokenLexer(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle '.' connected identifiers\n\n      if (current === '.') {\n        style = state.tokenize(stream, state);\n\n        if (style === 'variable') {\n          return 'variable';\n        } else {\n          return ERRORCLASS;\n        }\n      }\n\n      var delimiter_index = '[({'.indexOf(current);\n\n      if (delimiter_index !== -1) {\n        indent(stream, state);\n      }\n\n      if (indentInfo === 'dedent') {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n\n      delimiter_index = '])}'.indexOf(current);\n\n      if (delimiter_index !== -1) {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n\n      return style;\n    }\n\n    var external = {\n      electricChars: \"dDpPtTfFeE \",\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          lastToken: null,\n          currentIndent: 0,\n          nextLineIndent: 0,\n          doInCurrentLine: false\n        };\n      },\n      token: function (stream, state) {\n        if (stream.sol()) {\n          state.currentIndent += state.nextLineIndent;\n          state.nextLineIndent = 0;\n          state.doInCurrentLine = 0;\n        }\n\n        var style = tokenLexer(stream, state);\n        state.lastToken = {\n          style: style,\n          content: stream.current()\n        };\n        return style;\n      },\n      indent: function (state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      lineComment: \"'\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-vb\", \"vb\");\n});"],"sourceRoot":""}