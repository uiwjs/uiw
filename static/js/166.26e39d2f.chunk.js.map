{"version":3,"sources":["../node_modules/codemirror/mode/smarty/smarty.js"],"names":["CodeMirror","defineMode","config","parserConf","last","rightDelimiter","leftDelimiter","version","baseMode","getMode","keyFunctions","regs","operatorChars","validIdentifier","stringChar","cont","style","lastType","doesNotCount","stream","pos","string","length","test","charAt","tokenTop","state","terminator","scan","nextMatch","indexOf","match","eat","parser","tokenize","chain","eol","next","depth","tokenSmarty","slice","token","base","ch","eatWhile","quote","prevChar","currChar","peek","str","c","i","j","startState","copyState","innerMode","mode","indent","text","line","Pass","blockCommentStart","blockCommentEnd","defineMIME","mod"],"mappings":"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","file":"static/js/166.26e39d2f.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function (config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n    var last;\n\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    } // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n\n\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" && (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    } // parsing Smarty content\n\n\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        }\n\n        if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n\n        if (ch != \"/\") {\n          str += ch;\n        }\n\n        var c = null;\n\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n\n        for (var i = 0, j = keyFunctions.length; i < j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function (stream, state) {\n        var prevChar = null;\n        var currChar = null;\n\n        while (!stream.eol()) {\n          currChar = stream.peek();\n\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n\n          prevChar = currChar;\n        }\n\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    return {\n      startState: function () {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function (state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function (state) {\n        if (state.tokenize == tokenTop) return {\n          mode: baseMode,\n          state: state.base\n        };\n      },\n      token: function (stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function (state, text, line) {\n        if (state.tokenize == tokenTop && baseMode.indent) return baseMode.indent(state.base, text, line);else return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});"],"sourceRoot":""}